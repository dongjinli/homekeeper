set nocompatible
set fileencoding=utf-8
set termencoding=utf-8
set autoindent
set background=dark
set backspace=indent,eol,start
set complete=.,w,b,t,i
set completeopt=longest,menuone
set expandtab
set fileformat=unix
set fillchars=stl:_,stlnc:-,vert:\|,fold:\ ,diff:-
set guioptions+=c
set history=50
set hlsearch
set incsearch
set ignorecase
set indentexpr=
set infercase
set laststatus=2
set lazyredraw
set list
set listchars=tab:│\ ,trail:·
"set mouse=a
set nobackup
set noerrorbells
set nofoldenable
set novisualbell
set pastetoggle=<F1>
set ruler
set selection=inclusive
set selectmode=mouse
set shiftwidth=2
set showcmd
set showmode
set showmatch
set smartindent
set smarttab
set softtabstop=2
set statusline=%F%m%r%h%w[%L][%{&ff}]%y[%p%%][%04l,%04v]
set tabstop=2
set wildmenu
set wildchar=<TAB>
set wildignore=*.class,*.o,*.obj,*.bak,*.exe,*.jpg,*.png,*.gif
set wildmode=list:full
"set wrapmargin=80

syntax on
filetype plugin indent on
colorscheme default

" Normal, visual, select, and operator mode mappings
"   Map hjkl keys for navigating between splits
map <C-H> <C-W>h:res<CR>
map <C-J> <C-W>j:res<CR>
map <C-K> <C-W>k:res<CR>
map <C-L> <C-W>l:res<CR>
map <C-_> <C-W>_:res<CR>
"   Map C-\ to open definition in a new tab
map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
map <F2> :set expandtab!<CR>
map <F3> :set list!<CR>
"   Remove all trailing whitespace
map <silent> <F4> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>
"   Toggle highlighting of really long lines
map <silent> <F5>
      \ :if exists('w:long_line_match') <Bar>
      \   silent! call matchdelete(w:long_line_match) <Bar>
      \   unlet w:long_line_match <Bar>
      \ elseif &textwidth > 0 <Bar>
      \   let w:long_line_match = matchadd('OverColLimit', '\%>'.&tw.'v.\+', -1) <Bar>
      \ else <Bar>
      \   let w:long_line_match = matchadd('OverColLimit', '\%>80v.\+', -1) <Bar>
      \ endif<CR>
map <F12> :wincmd n<CR>:exe ":0r!find . -type f -not -path './.*' -not -name '*.swp'"<CR>1G:set buftype=nofile<CR>:res<CR>

" Normal mode mappings (same as nnoremap)
nmap ] <C-W>>
nmap [ <C-W><
nmap ; :
nmap ,/ :let @/=""<CR>
nmap ,cd :cd %:p:h<CR>
nmap ,d :bd<CR>:res<CR>
nmap ,f <C-W>f:res<CR>
nmap ,g :FindFile<CR>
nmap ,h :set hlsearch!<CR>
nmap ,n :set number!<CR>
nmap ,q :q!<CR>:res<CR>
nmap ,r :res<CR>
"nmap ,s " Used by slime.vim
nmap <silent> ,t :!ctags -R * &<CR>:FindFileCacheClear<CR>:FindFileCache .<CR><CR>
"nmap ,v " Used by slime.vim
nmap ,w :set wrap!<CR>
"nmap ,x " Used by slime.vim

" Insert mode mappings (same as inoremap)
"   When an auto-complete menu is presented, the first item is selected by
"   default
imap <expr> <C-n> pumvisible() ? '<C-n>' :
    \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
"   Simulates <C-X><C-O> to bring up omni-complete, and simulates <C-N><C-P>
"   to remove the longest common text
imap <expr> <M-,> pumvisible() ? '<C-n>' :
    \ '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

" Highlight really long lines
highlight OverColLimit ctermbg=darkblue

" Highlight all trailing whitespace
au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\s\+$', -1)

" VimClojure
let g:vimclojure#DynamicHighlighting = 1

" Source slime.vim to allow for SLIME like functionality
source $HOME/.vim/slime.vim

" Source project specific vim stuff if it exists
set secure
au BufEnter,BufReadPost * silent! source ./project.vim
